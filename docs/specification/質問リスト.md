# 評価テーブル追加に関する質問リスト

## 概要
データベースに以下の2つのテーブルを追加する際の確認事項です：
- `evaluation_result_table`: 評価結果テーブル
- `evaluation_data_table`: 評価データテーブル

## 1. データ型について

### 1.1 true_positiveフィールド
- **提案**: `REAL`型（0.0〜1.0の範囲の正解率）
- **質問**: このデータ型で問題ないでしょうか？
- **代替案**: `TEXT`型（パーセンテージ表記）、`INTEGER`型（0-100の整数）
- 回答：OKです。

### 1.2 false_positiveフィールド
- **現状**: 実装中のため空欄
- **質問**: 将来的にどのような値が入る予定でしょうか？
- **選択肢**: 
  - 数値（0.0〜1.0の範囲）
  - パーセンテージ
  - その他の形式
- 回答：1時間当たりの過検知数[回/h]を記載予定です。0.0~上限なしの実数としてください。

## 2. 関係性について

### 2.1 evaluation_result_table.algorithm_ID
- **質問**: これは特定のアルゴリズムの評価結果を表すということでしょうか？
- **確認事項**: 1つのアルゴリズムに対して複数の評価結果が存在する可能性はありますか？
- 回答：database.db内のalgorithm_tableのIDと同じです。

### 2.2 evaluation_data_table.algorithm_output_ID
- **質問**: 個別のアルゴリズム出力に対する評価データということでしょうか？
- **確認事項**: 1つのアルゴリズム出力に対して複数の評価データが存在する可能性はありますか？
- 回答：database.db内のcore_lib_output_tableのIDと同じです。

## 3. パス管理について

### 3.1 相対パス
- **提案**: database.dbからの相対パスで記録
- **質問**: 現在の設計思想に従って実装するという理解で正しいでしょうか？
- 回答：OKです。

### 3.2 パス形式の統一
- **提案**: `pathlib.Path`を使用して自動処理
- **質問**: Windows環境（`\`）とLinux環境（`/`）のパス区切り文字統一はこの方法でよろしいでしょうか？
- 回答：OKです。

## 4. 制約について

### 4.1 NULL制約
- **質問**: `false_positive`以外のフィールドはNOT NULL制約を設けるべきでしょうか？
- **対象フィールド**: 
  - `evaluation_result_table`: version, algorithm_ID, true_positive, evaluation_result_dir
  - `evaluation_data_table`: evaluation_result_ID, algorithm_output_ID, correct_task_num, total_task_num, evaluation_data_path
- 回答：今は空欄ですが、将来的には記載予定です。NULLも許容してください。

### 4.2 外部キー制約
- **提案**: `ON DELETE RESTRICT`（参照データの削除を防止）
- **質問**: この削除時の動作でよろしいでしょうか？
- 回答：OKです。

## 5. インデックスについて

### 5.1 検索効率
- **提案**: 頻繁に検索されるフィールドにインデックスを作成
- **対象フィールド**: 
  - `version`
  - `algorithm_ID`
  - `evaluation_result_ID`
- **質問**: これらのインデックス作成は必要でしょうか？
- 回答：いったん作りをシンプルにするため、無しです。

## 6. 追加のフィールドについて

### 6.1 評価日時
- **提案**: `evaluation_timestamp`フィールドを追加
- **質問**: 評価が実行された日時を記録するフィールドは必要でしょうか？
- 回答：OKです。

### 6.2 評価者/実行環境
- **提案**: 評価を実行した環境やユーザー情報を記録するフィールド
- **質問**: これらの情報は記録する必要がありますか？
- 回答：いったん記載しないです。

## 7. その他の確認事項

### 7.1 データ整合性
- **質問**: `correct_task_num <= total_task_num`の制約は必要でしょうか？
- 回答：OKです。

### 7.2 バージョン管理
- **質問**: 評価エンジンのバージョン履歴は必要でしょうか？（自己参照テーブル化）
- 回答：不要です。

### 7.3 評価メトリクス
- **質問**: 将来的に他の評価指標（precision, recall, F1-score等）を追加する予定はありますか？
- 回答：あります。

---

## 8. 課題分析テーブル追加に関する質問（新規）

### 8.1 テーブル構成の確認
- 提案テーブル:
  - `analysis_result_table`（課題分析の1実行あたり1レコード）
  - `problem_table`（分析で抽出された課題を管理）
  - `analysis_data_table`（各評価データに対する課題分析結果）
- 質問: テーブル名は上記で確定してよいでしょうか？（プレフィックスや命名規則の希望はありますか？）
- 回答：OKです。

### 8.2 データ型・表現
- `analysis_data_isproblem`: SQLiteでは `BOOLEAN` の代わりに `INTEGER CHECK (analysis_data_isproblem IN (0,1))` で0/1表現を想定。質問: この方針で問題ありませんか？
- 回答：OKです。
- `analysis_timestamp`: 形式は `YYYY-MM-DD HH:MM:SS` で文字列保存を想定。質問: タイムゾーン表記は不要でよいですか？
- 回答：OKです。日本時間を基準として記載して。

### 8.3 文字列長とステータス
- `problem_status`: 自由入力の `TEXT` とします。質問: 値の候補（例: open/doing/done 等）を将来定義しますか？ いまは制約なしでよいですか？
- 回答：OKです。
- `*_dir`/`*_path`: 既存方針にならい `database.db` からの相対パスで保存。質問: 先頭にスラッシュ（絶対パス）禁止で統一しますか？
- 回答：OKです。

### 8.4 外部キーと削除動作
- 参照関係:
  - `analysis_result_table.evaluation_result_ID` → `evaluation_result_table.evaluation_result_ID`
  - `analysis_data_table.evaluation_data_ID` → `evaluation_data_table.evaluation_data_ID`
  - `analysis_data_table.analysis_result_ID` → `analysis_result_table.analysis_result_ID`
  - `analysis_data_table.problem_ID` → `problem_table.problem_ID`
- 削除時: すべて `ON DELETE RESTRICT` を予定。質問: この動作で確定でよいですか？
- 回答：以下の方針で確定します（既存データ保護を最優先）。
  - `evaluation_result_table` の削除 → 参照する `analysis_result_table` が存在すると削除不可（RESTRICT）
  - `analysis_result_table` の削除 → 参照する `problem_table` / `analysis_data_table` が存在すると削除不可（RESTRICT）
  - `evaluation_data_table` の削除 → 参照する `analysis_data_table` が存在すると削除不可（RESTRICT）
  - `problem_table` の削除 → 参照する `analysis_data_table` が存在すると削除不可（RESTRICT）
  - これにより参照整合性を維持し、誤削除で孤児が生じないようにします。

### 8.5 ビジネスルール
- `analysis_data_isproblem = 0` のとき `problem_ID` は `NULL` を許容、`1` のとき `problem_ID` は `NOT NULL` を満たす必要がある、というアプリケーションレベル検証を実装予定。質問: この仕様で問題ありませんか？（DBレベルの複合CHECKはSQLite制約上難しいため）
- 回答：OKです。

### 8.6 インデックス
- 初期はインデックス無しを踏襲。将来的に必要なら `evaluation_result_ID` / `analysis_result_ID` / `evaluation_data_ID` に付与予定。質問: 初期はインデックス無しでよいですか？
- 回答：インデックス（Index）は検索を速くするための付加データ構造です。書き込み（INSERT/UPDATE/DELETE）はやや遅くなりますが、該当列での検索やJOINが高速化されます。現段階では運用の単純さを優先しインデックス無しとし、将来的にクエリ頻度が高い列（例: `analysis_result_ID`, `evaluation_result_ID`, `evaluation_data_ID`）に追加検討します。